<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="清野君"><title>Solidity学习笔记2 - 值类型与引用类型 · 清野流云</title><meta name="description" content="值类型与引用类型由于Solidity是一个静态类型的语言，所以编译时需明确指定变量的类型（包括本地变量或状态变量），Solidity编程语言提供了一些基本类型(elementary types)可以用来组合成复杂类型。
类型可以与不同运算符组合，支持表达式运算，可以通过表达式的执行顺序来了解执行顺序"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/Blog/css/style.css"><link rel="stylesheet" href="/Blog/css/blog_basic.css"><link rel="stylesheet" href="/Blog/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/Blog/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">清野流云</a></h3></div></div><ul class="social-links"></ul><div class="footer"><!-- a(target="_blank", href="/")--><!--   span Theme by --><!-- a(href="https://www.caicai.me")  CaiCai --><!-- span &--><!-- a(href="https://github.com/Ben02/hexo-theme-Anatole")  Ben--><!-- .by_farbox--><!--   a(href="https://hexo.io/zh-cn/", target="_blank") Proudly published with Hexo&#65281;--></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="http://wqy.fun/Blog">首页</a></li><!-- li--><!--   if is_current('about')--><!--     a.current(href="/about")= __('About')			--><!--   else--><!--     a(href="/about")= __('About')--><li><a href="http://wqy.fun/Blog/archives">归档</a></li><!-- li--><!--   if is_current('links')--><!--     a.current(href="/links")= __('Links')					--><!--   else--><!--     a(href="/links")= __('Links')		--></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Solidity学习笔记2 - 值类型与引用类型</a></h3></div><div class="post-content"><h2 id="值类型与引用类型"><a href="#值类型与引用类型" class="headerlink" title="值类型与引用类型"></a>值类型与引用类型</h2><p>由于Solidity是一个静态类型的语言，所以编译时需明确指定变量的类型（包括<code>本地变量</code>或<code>状态变量</code>），<code>Solidity</code>编程语言提供了一些<code>基本类型(elementary types)</code>可以用来组合成复杂类型。</p>
<p>类型可以与不同运算符组合，支持表达式运算，可以通过表达式的执行顺序来了解执行顺序。</p>
<h3 id="值类型-Value-Type"><a href="#值类型-Value-Type" class="headerlink" title="值类型(Value Type)"></a>值类型(Value Type)</h3><p><code>值类型</code>包含</p>
<ul>
<li><code>布尔(Booleans)</code></li>
<li><code>整型(Integer)</code></li>
<li><code>地址(Address)</code></li>
<li><code>定长字节数组(fixed byte arrays)</code></li>
<li><code>有理数和整型(Rational and Integer Literals</code>，<code>String literals)</code></li>
<li><code>枚举类型(Enums)</code></li>
<li><code>函数(Function Types)</code></li>
</ul>
<p>为什么会叫<code>值类型</code>，是因为上述这些类型在传值时，总是值传递<a href="https://solidity.tryblockchain.org/Solidity-Type-类型.html#fn1" target="_blank" rel="external">1</a>。比如在函数传参数时，或进行变量赋值时。</p>
<h3 id="引用类型-Reference-Types"><a href="#引用类型-Reference-Types" class="headerlink" title="引用类型(Reference Types)"></a>引用类型(Reference Types)</h3><p>复杂类型，占用空间较大的。在拷贝时占用空间较大。所以考虑通过引用传递。常见的引用类型有：</p>
<ul>
<li>不定长字节数组（bytes）</li>
<li>字符串（string）</li>
<li>数组（Array）</li>
<li>结构体（Struts）</li>
</ul>
<h4 id="布尔-Booleans"><a href="#布尔-Booleans" class="headerlink" title="布尔(Booleans)"></a>布尔(Booleans)</h4><p><code>bool</code>: 可能的取值为常量值<code>true</code>和<code>false</code>.</p>
<p>支持的运算符：</p>
<ul>
<li>！逻辑非</li>
<li>&amp;&amp; 逻辑与</li>
<li>|| 逻辑或</li>
<li>== 等于</li>
<li>！= 不等于</li>
</ul>
<p>备注：运算符<code>&amp;&amp;</code>和<code>||</code>是短路运算符，如<code>f(x)||g(y)</code>，当<code>f(x)</code>为真时，则不会继续执行<code>g(y)</code>。</p>
<h4 id="整型-Integer"><a href="#整型-Integer" class="headerlink" title="整型(Integer)"></a>整型(Integer)</h4><p><code>int/uint</code>：变长的有符号或无符号整型。变量支持的步长以<code>8</code>递增，支持从<code>uint8</code>到<code>uint256</code>，以及<code>int8</code>到<code>int256</code>。需要注意的是，<code>uint</code>和<code>int</code>默认代表的是<code>uint256</code>和<code>int256</code>。<strong>256是标识最大数字为2的256次方。</strong></p>
<p>支持的运算符：</p>
<ul>
<li>比较：<code>&lt;=</code>，<code>&lt;</code>，<code>==</code>，<code>!=</code>，<code>&gt;=</code>，<code>&gt;</code>，返回值为<code>bool</code>类型。</li>
<li>位运算符：<code>&amp;</code>，<code>|</code>，（<code>^</code>异或），（<code>~</code>非）。</li>
<li>数学运算：<code>+</code>，<code>-</code>，一元运算<code>+</code>，<code>*</code>，<code>/</code>，（<code>%</code>求余），（<code>**</code>平方）。</li>
</ul>
<p>整数除法总是截断的，但如果运算符是字面量，则不会截断(后面会进一步提到)。另外除<code>0</code>会抛异常 ，我们来看看下面的这个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">pragma solidity ^0.4.0;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">// simple store example</div><div class="line"></div><div class="line">contract simpleStorage&#123;</div><div class="line"></div><div class="line">    uint valueStore; //</div><div class="line"></div><div class="line">    </div><div class="line"></div><div class="line">    function add(uint x, uint y) returns (uint z)&#123;</div><div class="line"></div><div class="line">        z = x + y;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    function divide() returns (uint z)&#123;</div><div class="line"></div><div class="line">        uint x = 1;</div><div class="line"></div><div class="line">        uint y = 2;</div><div class="line"></div><div class="line">        z = x / y;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="整数字面量"><a href="#整数字面量" class="headerlink" title="整数字面量"></a>整数字面量</h5><p>整数字面量，由包含0-9的数字序列组成，默认被解释成十进制。在<code>Solidity</code>中不支持八进制，前导<code>0</code>会被默认忽略，如<code>0100</code>，会被认为是<code>100</code>。</p>
<p>小数由<code>.</code>组成，在他的左边或右边至少要包含一个数字。如<code>1.</code>，<code>.1</code>，<code>1.3</code>均是有效的小数。</p>
<p>字面量本身支持任意精度，也就是可以不会运算溢出，或除法截断。但当它被转换成对应的非字面量类型，如整数或小数。或者将他们与非字面量进行运算，则不能保证精度了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">pragma solidity ^0.4.0;</div><div class="line"></div><div class="line">contract IntegerLiteral&#123;</div><div class="line">  function integerTest() returns (uint, uint)&#123;</div><div class="line">    //超出运算字长了</div><div class="line">    var i = (2**800 + 1) - 2**800;</div><div class="line">    var j = 1/3*3;</div><div class="line">    //小数运算</div><div class="line">    var k = 0.5*8;</div><div class="line">    return (i, j);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总之来说就是，字面量怎么都计算都行，但一旦转为对应的变量后，再计算就不保证精度啦。</p>
<h4 id="地址-Address"><a href="#地址-Address" class="headerlink" title="地址(Address)"></a>地址(Address)</h4><h5 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h5><p>地址： 以太坊地址的长度，大小20个字节，160位，所以可以用一个<code>uint160</code>编码。地址是所有合约的基础，所有的合约都会继承地址对象，也可以随时将一个地址串，得到对应的代码进行调用。当然地址代表一个普通帐户时，就没有这么多丰富的功能啦。</p>
<h5 id="支持的运算符"><a href="#支持的运算符" class="headerlink" title="支持的运算符"></a>支持的运算符</h5><ul>
<li><code>&lt;=</code>，<code>&lt;</code>，<code>==</code>，<code>!=</code>，<code>&gt;=</code>和<code>&gt;</code></li>
</ul>
<h5 id="地址类型的成员"><a href="#地址类型的成员" class="headerlink" title="地址类型的成员"></a>地址类型的成员</h5><p>属性：<code>balance</code><br>函数：<code>send()</code>，<code>call()</code>，<code>delegatecall()</code>，<code>callcode()</code>。</p>
<h5 id="地址字面量"><a href="#地址字面量" class="headerlink" title="地址字面量"></a>地址字面量</h5><p>十六进制的字符串，凡是能通过地址合法性检查（address checksum test）<a href="https://solidity.tryblockchain.org/Solidity-Type-Address-地址.html#fn2" target="_blank" rel="external">2</a>，就会被认为是地址，如<code>0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF</code>。需要注意的是39到41位长的没有通过地址合法性检查的，会提示一个警告，但会被视为普通的有理数字面量。</p>
<h5 id="balance"><a href="#balance" class="headerlink" title="balance"></a><code>balance</code></h5><p>通过它能得到一个地址的余额。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">pragma solidity ^0.4.0;</div><div class="line"></div><div class="line">contract addressTest&#123;</div><div class="line">    </div><div class="line">    function getBalance(address addr) returns (uint)&#123;</div><div class="line">        return addr.balance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="this"><a href="#this" class="headerlink" title="this"></a><code>this</code></h5><p>如果只是想得到当前合约的余额，其实可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">pragma solidity ^0.4.0;</div><div class="line"></div><div class="line">contract addressTest&#123;</div><div class="line">    </div><div class="line">    function getBalance() returns (uint)&#123;</div><div class="line">        return this.balance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>原因是对于合约来说，地址代表的就是合约本身，合约对象默认继承自地址对象，所以内部有地址的属性。</p>
<h5 id="地址的方法send"><a href="#地址的方法send" class="headerlink" title="地址的方法send()"></a>地址的方法<code>send()</code></h5><p>用来向某个地址发送货币(货币单位是<code>wei</code>)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">pragma solidity ^0.4.0;</div><div class="line"></div><div class="line">//请注意这个仅是Demo，请不要用到正式环境</div><div class="line">contract PayTest &#123;</div><div class="line">    //得到当前合约的余额</div><div class="line">    function getBalance() returns (uint) &#123;</div><div class="line">        return this.balance;//0</div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    //向当前合约存款</div><div class="line">    function deposit() payable returns(address addr, uint amount, bool success)&#123;</div><div class="line">        //msg.sender 全局变量，调用合约的发起方</div><div class="line">        //msg.value 全局变量，调用合约的发起方转发的货币量，以wei为单位。</div><div class="line">        //send() 执行的结果</div><div class="line">        return (msg.sender, msg.value, this.send(msg.value));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个合约实现的是充值。<code>this.send(msg.value)</code>意指向合约自身发送<code>msg.value</code>量的以太币。<code>msg.value</code>是合约调用方附带的以太币。</p>
<p><code>send()</code>方法执行时有一些风险</p>
<ol>
<li>调用递归深度不能超1024。</li>
<li>如果<code>gas</code>不够，执行会失败。</li>
<li>所以使用这个方法要检查成功与否。或为保险起见，货币操作时要使用一些最佳实践。</li>
</ol>
<p><strong>如果执行失败，将会回撤所有交易，所以务必留意返回结果。</strong></p>
<h5 id="call-，callcode-和delegatecall"><a href="#call-，callcode-和delegatecall" class="headerlink" title="call()，callcode()和delegatecall()"></a><code>call()</code>，<code>callcode()</code>和<code>delegatecall()</code></h5><p>为了同一些不支持ABI协议的进行直接交互（一般的<code>web3.js</code>，<code>soldity</code>都是支持的）。可以使用<code>call()</code>函数，用来向另一个合约发送原始数据。参数支持任何类型任意数量。每个参数会按规则(规则是按ABI<a href="https://solidity.tryblockchain.org/Solidity-Type-Address-地址.html#fn4" target="_blank" rel="external">4</a>)打包成32字节并一一拼接到一起。</p>
<p><code>call()</code>方法支持ABI协议[ABI]定义的函数选择器。如果第一个参数恰好4个字节，在这种情况下，会被认为根据ABI协议定义的函数器指定的函数签名[ABI]。所以如果你只是想发送消息体，需要避免第一个参数是4个字节。</p>
<p><code>call</code>方法返回一个<code>bool</code>值，以表明执行成功还是失败。正常结束返回<code>true</code>，异常终止返回<code>false</code>。我们无法解析返回结果，因为这样我们得事前知道返回的数据的编码和数据大小（这里的潜在假设是不知道对方使用的协议格式，所以也不会知道返回的结果如何解析，有点祼协议测试的感觉）。</p>
<p>同样我们也可以使用<code>delegatecall()</code>，<strong>它与<code>call</code>方法的区别在于，仅仅是代码会执行，而其它方面，如（存储，余额等）都是用的当前的合约的数据。</strong><code>delegatecall()</code>方法的目的是用来执行另一个合约中的工具库。所以开发者需要保证两个合约中的存储变量能兼容，来保证<code>delegatecall()</code>能顺利执行。</p>
<p>在homestead阶段之前，仅有一个受限的多样的<code>callcode()</code>方法可用，但并未提供对<code>msg.sender</code>，<code>msg.value</code>的访问权限。</p>
<p>上面的这三个方法<code>call()</code>，<code>delegatecall()</code>，<code>callcode()</code>都是底层的消息传递调用，最好仅在万不得已才进行使用，因为他们破坏了Solidity的类型安全。</p>
<p>关于<code>call()</code>函数究竟发的什么消息体，函数选择器究竟怎么用，参见<a href="http://me.tryblockchain.org/Solidity-call-callcode-delegatecall.html" target="_blank" rel="external">这个文章</a>的挖掘。</p>
<blockquote>
<p>上述的函数都是底层的函数，使用时要异常小心。当调用一个未知的，可能是恶意的合约时，当你把控制权交给它，它可能回调回你的合约，所以要准备好在调用返回时，应对你的状态变量可能被恶意篡改的情况。</p>
</blockquote>
<hr>
<ol>
<li>如果你想了解更多关于地址的由来，UTXO等，可以参考: <a href="http://me.tryblockchain.org/Solidity的地址类型.html" target="_blank" rel="external">http://me.tryblockchain.org/Solidity%E7%9A%84%E5%9C%B0%E5%9D%80%E7%B1%BB%E5%9E%8B.html</a> <a href="https://solidity.tryblockchain.org/Solidity-Type-Address-地址.html#fnref1" target="_blank" rel="external">↩</a></li>
<li>为防止录入地址有误，一种格式化地址后来确认地址有效性的方案，<a href="https://github.com/ethereum/EIPs/issues/55" target="_blank" rel="external">https://github.com/ethereum/EIPs/issues/55</a> <a href="https://solidity.tryblockchain.org/Solidity-Type-Address-地址.html#fnref2" target="_blank" rel="external">↩</a></li>
<li>原因详见实现以太币支付的文章，<a href="http://me.tryblockchain.org/支付相关.html" target="_blank" rel="external">http://me.tryblockchain.org/%E6%94%AF%E4%BB%98%E7%9B%B8%E5%85%B3.html</a> <a href="https://solidity.tryblockchain.org/Solidity-Type-Address-地址.html#fnref3" target="_blank" rel="external">↩</a></li>
<li>关于ABI协议的详细说明：<a href="http://me.tryblockchain.org/Solidity-abi-abstraction.html" target="_blank" rel="external">http://me.tryblockchain.org/Solidity-abi-abstraction.html</a> <a href="https://solidity.tryblockchain.org/Solidity-Type-Address-地址.html#fnref4" target="_blank" rel="external">↩</a></li>
</ol>
<h4 id="字节数组-byte-arrays"><a href="#字节数组-byte-arrays" class="headerlink" title="字节数组(byte arrays)"></a>字节数组(byte arrays)</h4><h5 id="定长字节数组（Fixed-size-byte-arrays）"><a href="#定长字节数组（Fixed-size-byte-arrays）" class="headerlink" title="定长字节数组（Fixed-size byte arrays）"></a>定长字节数组（Fixed-size byte arrays）</h5><p><code>bytes1</code>， … ，<code>bytes32</code>，允许值以步长<code>1</code>递增。<code>byte</code>默认表示<code>byte1</code>。</p>
<h5 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h5><p>比较：<code>&lt;=</code>，<code>&lt;</code>，<code>==</code>，<code>!=</code>，<code>&gt;=</code>，<code>&gt;</code>，返回值为<code>bool</code>类型。</p>
<p>位运算符：<code>&amp;</code>，<code>|</code>，<code>^</code>(异或)，<code>~</code>非</p>
<p>支持序号的访问，与大多数语言一样，取值范围[0, n)，其中<code>n</code>表示长度。</p>
<h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><p><code>.length</code>表示这个字节数组的长度（只读）。</p>
<h5 id="动态大小的字节数组"><a href="#动态大小的字节数组" class="headerlink" title="动态大小的字节数组"></a>动态大小的字节数组</h5><p><code>bytes</code>： 动态长度的字节数组，参见<a href="https://solidity.tryblockchain.org/Solidity-Array-数组.html" target="_blank" rel="external">数组(Arrays)</a>。非值类型<a href="https://solidity.tryblockchain.org/Solidity-Type-ByteArrays-字节数组.html#fn1" target="_blank" rel="external">1</a>。</p>
<p><code>string</code>： 动态长度的UTF-8编码的字符类型，参见<a href="https://solidity.tryblockchain.org/Solidity-Array-数组.html" target="_blank" rel="external">数组(Arrays)</a>。非值类型[valueType]。</p>
<p>一个好的使用原则是:</p>
<ul>
<li><code>bytes</code>用来存储任意长度的字节数据，<code>string</code>用来存储任意长度的<code>UTF-8</code>编码的字符串数据。</li>
<li>如果长度可以确定，尽量使用定长的如<code>byte1</code>到<code>byte32</code>中的一个，因为这样更省空间。</li>
</ul>
<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>枚举类型是在Solidity中的一种用户自定义类型。他可以显示的转换与整数进行转换，但不能进行隐式转换。显示的转换会在运行时检查数值范围，如果不匹配，将会引起异常。枚举类型应至少有一名成员。我们来看看下面的例子吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">pragma solidity ^0.4.0;</div><div class="line"></div><div class="line">contract test &#123;</div><div class="line">    enum ActionChoices &#123; GoLeft, GoRight, GoStraight, SitStill &#125;</div><div class="line">    ActionChoices choice;</div><div class="line">    ActionChoices constant defaultChoice = ActionChoices.GoStraight;</div><div class="line"></div><div class="line">    function setGoStraight() &#123;</div><div class="line">        choice = ActionChoices.GoStraight;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Since enum types are not part of the ABI, the signature of &quot;getChoice&quot;</div><div class="line">    // will automatically be changed to &quot;getChoice() returns (uint8)&quot;</div><div class="line">    // for all matters external to Solidity. The integer type used is just</div><div class="line">    // large enough to hold all enum values, i.e. if you have more values,</div><div class="line">    // `uint16` will be used and so on</div><div class="line">    // 默认返回数字</div><div class="line">    function getChoice() returns (ActionChoices) &#123;</div><div class="line">        return choice;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    function getDefaultChoice() returns (uint) &#123;</div><div class="line">        return uint(defaultChoice);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="函数-Function-Types"><a href="#函数-Function-Types" class="headerlink" title="函数(Function Types)"></a>函数(Function Types)</h4><p>函数类型<a href="https://solidity.tryblockchain.org/Solidity-Type-Function-函数.html#fn1" target="_blank" rel="external">1</a>即是函数这种特殊的类型。</p>
<ul>
<li>可以将一个函数赋值给一个变量，一个函数类型的变量。</li>
<li>还可以将一个函数作为参数进行传递。</li>
<li>也可以在函数调用中返回一个函数。</li>
</ul>
<p>函数类型有两类;可分为<code>internal</code>和<code>external</code>函数。</p>
<h5 id="内部函数-internal"><a href="#内部函数-internal" class="headerlink" title="内部函数(internal)"></a>内部函数(internal)</h5><p>因为不能在当前合约的上下文环境以外的地方执行，内部函数只能在当前合约内被使用。如在当前的代码块内，包括内部库函数，和继承的函数中。</p>
<h5 id="外部函数（External）"><a href="#外部函数（External）" class="headerlink" title="外部函数（External）"></a>外部函数（External）</h5><p>外部函数由地址和函数方法签名两部分组成。可作为<code>外部函数调用</code>的参数，或者由<code>外部函数调用</code>返回。</p>
<h5 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h5><p>完整的函数的定义如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">function (&lt;parameter types&gt;) &#123;internal(默认)|external&#125; [constant] [payable] [returns (&lt;return types&gt;)]</div></pre></td></tr></table></figure>
<p>若不写类型，默认的函数类型是<code>internal</code>的。如果函数没有返回结果，则必须省略<code>returns</code>关键字。下面我们通过一个例子来了解一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">pragma solidity ^0.4.0;</div><div class="line"></div><div class="line">contract Test&#123;</div><div class="line">    //默认是internal类型的</div><div class="line">    function noParameter() returns (uint)&#123;&#125;</div><div class="line"></div><div class="line">    //无返回结果</div><div class="line">    function noReturn1(uint x) &#123;&#125;</div><div class="line"></div><div class="line">    //如果无返回结果，必须省略`returns`关键字</div><div class="line">    //function noReturn2(uint x) returns &#123;&#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果一个函数变量没有初始化，直接调用它将会产生异常。如果<code>delete</code>了一个函数后调用，也会发生同样的异常。</p>
<p>如果<code>外部函数</code>类型在<code>Solidity</code>的上下文环境以外的地方使用，他们会被视为<code>function</code>类型。编码为20字节的函数所在地址，紧跟4字节的函数方法签名<a href="https://solidity.tryblockchain.org/Solidity-Type-Function-函数.html#fn2" target="_blank" rel="external">2</a>的共占24字节的<code>bytes24</code>类型。</p>
<p>合约中的<code>public</code>的函数，可以使用<code>internal</code>和<code>external</code>两种方式来调用。下面来看看，两种方式的不同之处。</p>
<h5 id="函数的internal与external："><a href="#函数的internal与external：" class="headerlink" title="函数的internal与external："></a>函数的<code>internal</code>与<code>external</code>：</h5><p>调用一个函数<code>f()</code>时，我们可以直接调用<code>f()</code>，或者使用<code>this.f()</code>。但两者有一个区别。前者是通过<code>internal</code>的方式在调用，而后者是通过<code>external</code>的方式在调用。请注意，这里关于<code>this</code>的使用与大多数语言相背。下面通过一个例子来了解他们的不同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">pragma solidity ^0.4.5;</div><div class="line"></div><div class="line">contract FuntionTest&#123;</div><div class="line">    function internalFunc() internal&#123;&#125;</div><div class="line"></div><div class="line">    function externalFunc() external&#123;&#125;</div><div class="line"></div><div class="line">    function callFunc()&#123;</div><div class="line">        //直接使用内部的方式调用</div><div class="line">        internalFunc();</div><div class="line"></div><div class="line">        //不能在内部调用一个外部函数，会报编译错误。</div><div class="line">        //Error: Undeclared identifier.</div><div class="line">        //externalFunc();</div><div class="line"></div><div class="line">        //不能通过`external`的方式调用一个`internal`</div><div class="line">        //Member &quot;internalFunc&quot; not found or not visible after argument-dependent lookup in contract FuntionTest</div><div class="line">        //this.internalFunc();</div><div class="line"></div><div class="line">        //使用`this`以`external`的方式调用一个外部函数</div><div class="line">        this.externalFunc();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">contract FunctionTest1&#123;</div><div class="line">    function externalCall(FuntionTest ft)&#123;</div><div class="line">        //调用另一个合约的外部函数</div><div class="line">        ft.externalFunc();</div><div class="line">        </div><div class="line">        //不能调用另一个合约的内部函数</div><div class="line">        //Error: Member &quot;internalFunc&quot; not found or not visible after argument-dependent lookup in contract FuntionTest</div><div class="line">        //ft.internalFunc();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><code>数组</code>可以声明时指定长度，或者是变长的。对<code>storage</code><a href="https://solidity.tryblockchain.org/Solidity-Array-数组.html#fn1" target="_blank" rel="external">1</a>的数组来说，元素类型可以是任意的，类型可以是数组，映射类型，数据结构等。但对于<code>memory</code>[datalocation]的数组来说。如果函数是对外可见的<a href="https://solidity.tryblockchain.org/Solidity-Array-数组.html#fn2" target="_blank" rel="external">2</a>，那么函数参数不能是映射类型的数组，只能是支持ABI的类型<a href="https://solidity.tryblockchain.org/Solidity-Array-数组.html#fn3" target="_blank" rel="external">3</a>。</p>
<p>一个类型为T，长度为k的数组，可以声明为<code>T[k]</code>，而一个变长的数组则声明为<code>T[]</code>。<br>你还可以声明一个多维数据，如一个类型为<code>uint</code>的数组长度为5的变长数组，可以声明为<code>uint[][5] x</code>。需要留心的是，相比非区块链语言，多维数组的长度声明是反的。</p>
<p>要访问第三个动态数据的，第二个元素，使用<code>x[2][1]</code>。数组的序号是从0开始的，序号顺序与定义相反。</p>
<p><code>bytes</code>和<code>string</code>是一种特殊的数组。<code>bytes</code>类似<code>byte[]</code>，但在外部函数作为参数调用中，会进行压缩打包，更省空间，所以应该尽量使用<code>bytes</code><a href="https://solidity.tryblockchain.org/Solidity-Array-数组.html#fn4" target="_blank" rel="external">4</a>。<code>string</code>类似<code>bytes</code>，但不提供长度和按序号的访问方式。</p>
<p>由于<code>bytes</code>与<code>string</code>，可以自由转换，你可以将字符串<code>s</code>通过<code>bytes(s)</code>转为一个<code>bytes</code>。但需要注意的是通过这种方式访问到的是UTF-8编码的码流，并不是独立的一个个字符。比如中文编码是多字节，变长的，所以你访问到的很有可能只是其中的一个代码点。</p>
<p>类型为数组的状态变量，可以标记为<code>public</code>类型，从而让<code>Solidity</code>创建一个访问器，如果要访问数组的某个元素，指定数字下标就好了。</p>
<h5 id="创建一个数组"><a href="#创建一个数组" class="headerlink" title="创建一个数组"></a>创建一个数组</h5><p>可使用<code>new</code>关键字创建一个<code>memory</code>的数组。与<code>stroage</code>数组不同的是，你不能通过<code>.length</code>的长度来修改数组大小属性。我们来看看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">pragma solidity ^0.4.0;</div><div class="line"></div><div class="line">contract C &#123;</div><div class="line">    function f() &#123;</div><div class="line">        //创建一个memory的数组</div><div class="line">        uint[] memory a = new uint[](7);</div><div class="line">        </div><div class="line">        //不能修改长度</div><div class="line">        //Error: Expression has to be an lvalue.</div><div class="line">        //a.length = 100;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //storage</div><div class="line">    uint[] b;</div><div class="line">    </div><div class="line">    function g()&#123;</div><div class="line">        b = new uint[](7);</div><div class="line">        //可以修改storage的数组</div><div class="line">        b.length = 10;</div><div class="line">        b[9] = 100;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面的代码中，<code>f()</code>方法尝试调整数组<code>a</code>的长度，编译器报错<code>Error: Expression has to be an lvalue.</code>。但在<code>g()</code>方法中我们看到可以修改<a href="https://solidity.tryblockchain.org/Solidity-Array-数组.html#fn5" target="_blank" rel="external">5</a>。</p>
<h5 id="字面量及内联数组"><a href="#字面量及内联数组" class="headerlink" title="字面量及内联数组"></a>字面量及内联数组</h5><p>数组字面量，是指以表达式方式隐式声明一个数组，并作为一个数组变量使用的方式。下面是一个简单的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">pragma solidity ^0.4.0;</div><div class="line"></div><div class="line">contract C &#123;</div><div class="line">    function f() &#123;</div><div class="line">        g([uint(1), 2, 3]);</div><div class="line">    &#125;</div><div class="line">    function g(uint[3] _data) &#123;</div><div class="line">        // ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过数组字面量，创建的数组是<code>memory</code>的，同时还是定长的。元素类型则是使用刚好能存储的元素的能用类型，比如代码里的<code>[1, 2, 3]</code>，只需要<code>uint8</code>即可存储。由于<code>g()</code>方法的参数需要的是<code>uint</code>（默认的<code>uint</code>表示的其实是<code>uint256</code>），所以要使用<code>uint(1)</code>来进行类型转换。</p>
<p>还需注意的一点是，定长数组，不能与变长数组相互赋值，我们来看下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">pragma solidity ^0.4.0;</div><div class="line"></div><div class="line">contract C &#123;</div><div class="line">    function f() &#123;</div><div class="line">        // The next line creates a type error because uint[3] memory</div><div class="line">        // cannot be converted to uint[] memory.</div><div class="line">        uint[] x = [uint(1), 3, 4];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>限制的主要原因是，ABI不能很好的支持数组，已经计划在未来移除这样的限制。（当前的ABI接口，不是已经能支持数组了？）</p>
<h4 id="数组的属性和方法"><a href="#数组的属性和方法" class="headerlink" title="数组的属性和方法"></a>数组的属性和方法</h4><h5 id="length属性"><a href="#length属性" class="headerlink" title="length属性"></a>length属性</h5><p>数组有一个<code>.length</code>属性，表示当前的数组长度。<code>storage</code>的变长数组，可以通过给<code>.length</code>赋值调整数组长度。<code>memory</code>的变长数组不支持。</p>
<p>不能通过访问超出当前数组的长度的方式，来自动实现上面说的这种情况。<code>memory</code>数组虽然可以通过参数，灵活指定大小，但一旦创建，大小不可调整，对于变长数组，可以通过参数在编译期指定数组大小。</p>
<h5 id="push方法"><a href="#push方法" class="headerlink" title="push方法"></a>push方法</h5><p><code>storage</code>的变长数组和<code>bytes</code>都有一个<code>push()</code>，用于附加新元素到数据末端，返回值为新的长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">pragma solidity ^0.4.0;</div><div class="line"></div><div class="line">contract C &#123;</div><div class="line">    uint[] u;</div><div class="line">    bytes b;</div><div class="line">    </div><div class="line">    function testArryPush() returns (uint)&#123;</div><div class="line">        uint[3] memory a = [uint(1), 2, 3];</div><div class="line">        </div><div class="line">        u = a;</div><div class="line">        </div><div class="line">        return u.push(4);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    function testBytesPush() returns (uint)&#123;</div><div class="line">        b = new bytes(3);</div><div class="line">        return b.push(4);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="结构体-struct"><a href="#结构体-struct" class="headerlink" title="结构体(struct)"></a>结构体(struct)</h3><p><code>Solidity</code>提供<code>struct</code>来定义自定义类型。我们来看看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">pragma solidity ^0.4.0;</div><div class="line"></div><div class="line">contract CrowdFunding&#123;</div><div class="line">    struct Funder&#123;</div><div class="line">        address addr;</div><div class="line">        uint amount;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    struct Campaign&#123;</div><div class="line">        address beneficiary;</div><div class="line">        uint goal;</div><div class="line">        uint amount;</div><div class="line">        uint funderNum;</div><div class="line">        mapping(uint =&gt; Funder) funders;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    uint compaingnID;</div><div class="line">    mapping (uint =&gt; Campaign) campaigns;</div><div class="line">    </div><div class="line">    function candidate(address beneficiary, uint goal) returns (uint compaingnID)&#123;</div><div class="line">        // initialize</div><div class="line">        campaigns[compaingnID++] = Campaign(beneficiary, goal, 0, 0);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    function vote(uint compaingnID) payable &#123;</div><div class="line">        Campaign c = campaigns[compaingnID];</div><div class="line">        </div><div class="line">        //another way to initialize</div><div class="line">        c.funders[c.funderNum++] = Funder(&#123;addr: msg.sender, amount: msg.value&#125;);</div><div class="line">        c.amount += msg.value;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    function check(uint comapingnId) returns (bool)&#123;</div><div class="line">        Campaign c = campaigns[comapingnId];</div><div class="line">        </div><div class="line">        if(c.amount &lt; c.goal)&#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        uint amount = c.amount;</div><div class="line">        // incase send much more</div><div class="line">        c.amount = 0;</div><div class="line">        if(!c.beneficiary.send(amount))&#123;</div><div class="line">            throw;</div><div class="line">        &#125;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码向我们展示的一个简化版的众筹项目，其实包含了一些<code>struct</code>的使用。<code>struct</code>可以用于映射和数组中作为元素。其本身也可以包含映射和数组等类型。</p>
<p>我们不能声明一个<code>struct</code>同时将这个<code>struct</code>作为这个struct的一个成员。这个限制是基于结构体的大小必须是有限的。</p>
<p>虽然数据结构能作为一个<code>mapping</code>的值，但数据类型不能包含它自身类型的成员，因为数据结构的大小必须是有限的。</p>
<p>需要注意的是在函数中，将一个<code>struct</code>赋值给一个局部变量（默认是storage类型），实际是拷贝的引用，所以修改局部变量值时，会影响到原变量。</p>
<p>当然，你也可以直接通过访问成员修改值，而不用一定赋值给一个局部变量，如<code>campaigns[comapingnId].amount = 0</code></p>
<h3 id="映射-字典-mappings"><a href="#映射-字典-mappings" class="headerlink" title="映射/字典(mappings)"></a>映射/字典(mappings)</h3><p><code>映射</code>或字典类型，一种键值对的映射关系存储结构。定义方式为<code>mapping(_KeyType =&gt; _KeyValue)</code>。键的类型允许除<code>映射</code>外的所有类型，如数组，合约，枚举，结构体。值的类型无限制。</p>
<p><code>映射</code>可以被视作为一个哈希表，其中所有可能的键已被虚拟化的创建，被映射到一个默认值（二进制表示的零）。但在映射表中，我们并不存储键的数据，仅仅存储它的<code>keccak256</code>哈希值，用来查找值时使用。</p>
<p>因此，<code>映射</code>并没有长度，键集合（或列表），值集合（或列表）这样的概念。</p>
<p><code>映射</code>类型，仅能用来定义<code>状态变量</code>，或者是在内部函数中作为<code>storage</code>类型的引用。引用是指你可以声明一个，如<code>var storage mappVal</code>的用于存储状态变量的引用的对象，但你没办法使用非状态变量来初始化这个引用。</p>
<p>可以通过将<code>映射</code>标记为<code>public</code>，来让Solidity创建一个访问器。要想访问这样的<code>映射</code>，需要提供一个键值做为参数。如果<code>映射</code>的值类型也是<code>映射</code>，使用访问器访问时，要提供这个<code>映射</code>值所对应的键，不断重复这个过程。下面来看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">contract MappingExample&#123;</div><div class="line">    mapping(address =&gt; uint) public balances;</div><div class="line">    </div><div class="line">    function update(uint amount) returns (address addr)&#123;</div><div class="line">        balances[msg.sender] = amount;</div><div class="line">        return msg.sender;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于调试时，你不一定方便知道自己的发起地址，所以把这个函数，略微调整了一下，以在调用时，返回调用者的地址。编译上述合同后，可以先调用<code>update()</code>，执行成功后，查看调用信息，能看到你更新的地址，这样再查一下这个地址的在映射里存的值。</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2021-12-16</span><i class="fa fa-tag"></i><a href="/Blog/tags/Solidity/" title="Solidity" class="tag">Solidity </a></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,http://wqy.fun/Blog/2021/12/16/Solidity学习笔记2 - 数据类型/,清野流云,Solidity学习笔记2 - 值类型与引用类型,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/Blog/2021/12/17/Solidity学习笔记3 - 数据位置/" title="Solidity学习笔记3 - 数据位置" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/Blog/2021/12/16/Solidity学习笔记1 - 基本介绍/" title="Solidity学习笔记1 - 基本介绍" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/Blog/js/jquery.js"></script><script src="/Blog/js/jquery-migrate-1.2.1.min.js"></script><script src="/Blog/js/jquery.appear.js"></script></body></html>