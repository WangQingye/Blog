---
title: 重读高程-基本语法

date: 2019-7-6

tag: [javascript]
---

#### HTML

##### 异步加载脚本

- defer 标签 和 async 标签 都表示告诉浏览器先下载脚本但是等到DOM渲染完成后再执行。两者的不同点是defer会遵从脚本引入的顺序执行，但是async不一定，所以有互相引用时需要注意。
- 两者都只适用于外部脚本。

##### 文档模式（doctype）

一般分为混杂模式（quirks mode）和标准模式（standards mode）。浏览器默认是混杂模式，但是并不推荐，不同浏览器表现差异会很大，所以一般会强制开启标准模式：

##### <!-- HTML 4.01 严格型 -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
"http://www.w3.org/TR/html4/strict.dtd">
<!-- XHTML 1.0 严格型 -->
<!DOCTYPE html PUBLIC
"-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!-- HTML 5 -->
<!DOCTYPE html>



##### noscript标签

早期有的浏览器不支持javascript（或者脚本被禁用），所以会用这个标签在脚本无效的时候向用户显示一条消息。

### 基本概念

#### 语法：

- 标识符，即变量，函数，属性的名字：

  - 第一个字符必须是一个字母、下划线_或一个美元符号$。
  - 其他字符可以是字母、下划线、美元符号或数字。
  - 一般来说采用驼峰大小写格式。

- 严格模式：

  ```javascript
  // 这是一个编译指示(pragma)用于告诉支持的JavaScript引擎切换到严格模式
  "use strict";
  
  // 或者在函数内部
  function doSometing() {
      "use strict"
  }
  ```

- 变量类型：

对未初始化的变量和未定义的变量：

```javascript
var a;
alert(a); // undefined;
alert(b); // 报错
typeof a; // undefined;
typeof b; // undefined;
```

Null值表示一个空对象指针，所以 typeof null == undefined;

undefined 是派生于null值的，所以 null == undefined;

NaN参与任何计算都会返回NaN，所以NaN与任何值都不相等，包括其自身。所以要判断NaN，可以用isNaN函数：

```javascript

```

Number():

```javascript
var num1 = Number("Hello world!"); //NaN
var num1 = Number(undefined); //NaN
var num1 = Number(null); //0
var num2 = Number(""); //0
var num3 = Number("000011"); //11
var num4 = Number(true); //1

// 特别说明一下，一元操作符 + 号与Number效果相同； - 号是先执行Number后再变成负数。
```

parseInt() && parseFloat():

```javascript
var num1 = parseInt("1234blue"); // 1234
var num2 = parseInt("sdas123"); // NaN
var num3 = parseInt("0xA"); // 10（十六进制数）
var num4 = parseInt(22.5); // 22
var num5 = parseInt(070); // 56（八进制数）
var num5 = parseInt("070"); // 70（字符串会去掉前置的0）
var num6 = parseInt("70"); // 70（十进制数）
var num7 = parseInt("0xf"); // 15（十六进制数）

// parseInt 的第二个参数可以指定按什么进制去解析

var num1 = parseFloat("1234blue"); //1234 （整数）
var num2 = parseFloat("0xA"); //0
var num3 = parseFloat("22.5"); //22.5
var num4 = parseFloat("22.34.5"); //22.34
var num5 = parseFloat("0908.5"); //908.5
var num6 = parseFloat("3.125e7"); //31250000
```

##### 字符串：

ECMAScript 中的字符串是**不可变的**，也就是说，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首**先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量**。

除了null和undefined，其他的数据类型都有toString方法。转换类型函数String()，就是调用参数的toString方法。如果传入null和undefined，会返回“null”和"undefined"。

##### 对象：

在 ECMAScript 中，（就像 Java 中的 java.lang.Object 对象一样） Object 类型是所有它的实例的基础。换句话说，Object 类型所具有的任何属性和方法也同样存在于更具体的对象中。

Object的每个实例都具有下列属性和方法：

-  constructor ：保存着用于创建当前对象的构造函数。
- hasOwnProperty(propertyName) ：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（ propertyName ）必须以字符串形式指定（例如： o.hasOwnProperty("name") ）。
- isPrototypeOf(object) ：用于检查传入的对象是否是传入对象的原型。
- propertyIsEnumerable(propertyName) ：用于检查给定的属性是否能够使用 for-in 语句（本章后面将会讨论）来枚举。与 hasOwnProperty() 方法一样，作为参数的属性名必须以字符串形式指定。
- toLocaleString() ：返回对象的字符串表示，该字符串与执行环境的地区对应。
- toString() ：返回对象的字符串表示。
- valueOf() ：返回对象的字符串、数值或布尔值表示。通常与 toString() 方法的返回值
  相同。

#### 操作符

##### 一元操作符： ++ ； --

递增和递减，可以写在元素的前面或者后面。

执行前置递增和递减操作时，变量的值都是在语句被**求值以前改变**的（反之则是在求值之后才改变）。（在计算机科学领域，这种情况通常被称作副效应。

```javascript
var age = 29;
var anotherAge = --age + 2;
alert(age); // 输出 28
alert(anotherAge); // 输出 30

var num1 = 2;
var num2 = 20;
var num3 = num1-- + num2; //  等于 22
var num4 = num1 + num2; // 等于 21
```

- 加号 + ：

如果两个操作符都是数值，执行常规的加法计算，然后根据下列规则返回结果：
  如果有一个操作数是 NaN ，则结果是 NaN ；
  如果是 Infinity 加 Infinity ，则结果是 Infinity ；
  如果是 -Infinity 加 -Infinity ，则结果是 -Infinity ；
  如果是 Infinity 加 -Infinity ，则结果是 NaN ；
  如果是+0 加+0，则结果是+0；
  如果是0 加0，则结果是0；
  如果是+0 加0，则结果是+0。
**不过，如果有一个操作数是字符串，那么就要应用如下规则：**
  如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来；
  如果只有一个操作数是字符串，则将另一个操作数转换为字符串（调用toString），然后再将两个字符串拼接起来。

- 减号 - ：

  如果有一个操作数是字符串、布尔值、 null 或 undefined ，则先在后台调用 Number() 函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是 NaN ，则减法的结果就是 NaN ；
  如果有一个操作数是对象，则调用对象的 valueOf() 方法以取得表示该对象的数值。如果得到的值是 NaN ，则减法的结果就是 NaN 。如果对象没有 valueOf() 方法，则调用其 toString()方法并将得到的字符串转换为数值。

- 比较符号 > 、<、 >=、 <=
  比较符号都会返回一个布尔值，在不是数字的时候：

    如果两个操作数都是字符串，则比较两个字符串首字符对应的字符编码值。
    如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。
    如果一个操作数是对象，则调用这个对象的 valueOf() 方法，用得到的结果按照前面的规则执行比较。如果对象没有 valueOf() 方法，则调用 toString() 方法，并用得到的结果根据前面的规则执行比较。
    如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。

##### 逻辑操作符

逻辑非 ！：

逻辑非操作符也可以用于将一个值转换为与其对应的布尔值。而同时使用两个逻辑非操作符，实际上就会模拟 Boolean() 转型函数的行为。

逻辑与 && ：

在两个数值都是布尔的情况下，只要有一个是false，就都返回false。

但是逻辑与操作符可以应用于任何字符，常见的情况有：

  如果第一个操作数是对象，则返回第二个操作数；
  如果第二个操作数是对象，则只有在第一个操作数的求值结果为 true 的情况下才会返回该对象；
  如果两个操作数都是对象，则返回第二个操作数；
  如果有一个操作数是 null ，则返回 null ；
  如果有一个操作数是 NaN ，则返回 NaN ；
  如果有一个操作数是 undefined ，则返回 undefined 。

逻辑与操作属于**短路操作**，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。对于逻辑与操作而言，如果第一个操作数是 false ，则无论第二个操作数是什么都不重要，因为后面的代码不会再执行了。

逻辑或 || :

逻辑与操作也是一个短路操作。只要有一个true，就会返回true；

作用于其他数值时：

  如果第一个操作数是对象，则返回第一个操作数；
  如果第一个操作数的求值结果为 false ，则返回第二个操作数；
  如果两个操作数都是对象，则返回第一个操作数；
  如果两个操作数都是 null ，则返回 null ；
  如果两个操作数都是 NaN ，则返回 NaN ；
  如果两个操作数都是 undefined ，则返回 undefined 。

相等符号 = ：

== 和 ！= 都会先进行类型的强制转换，规则为：

  如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值—— false 转换为 0，而true 转换为 1；
  如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值；
  如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf() 方法，用得到的基本类型值按照前面的规则进行比较；
这两个操作符在进行比较时则要遵循下列规则。
 null 和 undefined 是相等的。
  要比较相等性之前，不能将 null 和 undefined 转换成其他任何值。
  如果有一个操作数是 NaN ，则相等操作符返回 false ，而不相等操作符返回 true 。重要提示：即使两个操作数都是 NaN ，相等操作符也返回 false ；因为按照规则， NaN 不等于 NaN 。
  如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true ；否则，返回 false 。

#### 语句

- do while 是后测试语句，会先执行一次再去判读，而while是前测试。

- label语句可以配合for循环精准控制代码流程，一般用于嵌套循环：

```javascript
var num = 0;
outermost:
for (var i=0; i < 10; i++) {
	for (var j=0; j < 10; j++) {
		if (i == 5 && j == 5) {
			break outermost; // 退出外层循环
		}
	num++;
	}
}
alert(num); //55
```

- switch 语句判断时使用的是全等