<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="清野君"><title>重读高程-基本语法 · 清野流云</title><meta name="description" content="HTML异步加载脚本
defer 标签 和 async 标签 都表示告诉浏览器先下载脚本但是等到DOM渲染完成后再执行。两者的不同点是defer会遵从脚本引入的顺序执行，但是async不一定，所以有互相引用时需要注意。
两者都只适用于外部脚本。

文档模式（doctype）一般分为混杂模式（quir"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/Blog/css/style.css"><link rel="stylesheet" href="/Blog/css/blog_basic.css"><link rel="stylesheet" href="/Blog/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/Blog/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">清野流云</a></h3></div></div><ul class="social-links"></ul><div class="footer"><!-- a(target="_blank", href="/")--><!--   span Theme by --><!-- a(href="https://www.caicai.me")  CaiCai --><!-- span &--><!-- a(href="https://github.com/Ben02/hexo-theme-Anatole")  Ben--><!-- .by_farbox--><!--   a(href="https://hexo.io/zh-cn/", target="_blank") Proudly published with Hexo&#65281;--></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="http://wqy.fun/Blog">首页</a></li><!-- li--><!--   if is_current('about')--><!--     a.current(href="/about")= __('About')			--><!--   else--><!--     a(href="/about")= __('About')--><li><a href="http://wqy.fun/Blog/archives">归档</a></li><!-- li--><!--   if is_current('links')--><!--     a.current(href="/links")= __('Links')					--><!--   else--><!--     a(href="/links")= __('Links')		--></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>重读高程-基本语法</a></h3></div><div class="post-content"><h4 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h4><h5 id="异步加载脚本"><a href="#异步加载脚本" class="headerlink" title="异步加载脚本"></a>异步加载脚本</h5><ul>
<li>defer 标签 和 async 标签 都表示告诉浏览器先下载脚本但是等到DOM渲染完成后再执行。两者的不同点是defer会遵从脚本引入的顺序执行，但是async不一定，所以有互相引用时需要注意。</li>
<li>两者都只适用于外部脚本。</li>
</ul>
<h5 id="文档模式（doctype）"><a href="#文档模式（doctype）" class="headerlink" title="文档模式（doctype）"></a>文档模式（doctype）</h5><p>一般分为混杂模式（quirks mode）和标准模式（standards mode）。浏览器默认是混杂模式，但是并不推荐，不同浏览器表现差异会很大，所以一般会强制开启标准模式：</p>
<h5 id=""><a href="#" class="headerlink" title=""></a><!-- HTML 4.01 严格型 --></h5><p>&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01//EN”<br>“<a href="http://www.w3.org/TR/html4/strict.dtd&quot;&gt;" target="_blank" rel="external">http://www.w3.org/TR/html4/strict.dtd&quot;&gt;</a><br><!-- XHTML 1.0 严格型 --><br>&lt;!DOCTYPE html PUBLIC<br>“-//W3C//DTD XHTML 1.0 Strict//EN”<br>“<a href="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;" target="_blank" rel="external">http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;</a><br><!-- HTML 5 --><br>&lt;!DOCTYPE html&gt;</p>
<h5 id="noscript标签"><a href="#noscript标签" class="headerlink" title="noscript标签"></a>noscript标签</h5><p>早期有的浏览器不支持javascript（或者脚本被禁用），所以会用这个标签在脚本无效的时候向用户显示一条消息。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><ul>
<li><p>标识符，即变量，函数，属性的名字：</p>
<ul>
<li>第一个字符必须是一个字母、下划线_或一个美元符号$。</li>
<li>其他字符可以是字母、下划线、美元符号或数字。</li>
<li>一般来说采用驼峰大小写格式。</li>
</ul>
</li>
<li><p>严格模式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这是一个编译指示(pragma)用于告诉支持的JavaScript引擎切换到严格模式</span></div><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"></div><div class="line"><span class="comment">// 或者在函数内部</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSometing</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="meta">    "use strict"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>变量类型：</p>
</li>
</ul>
<p>对未初始化的变量和未定义的变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a;</div><div class="line">alert(a); <span class="comment">// undefined;</span></div><div class="line">alert(b); <span class="comment">// 报错</span></div><div class="line"><span class="keyword">typeof</span> a; <span class="comment">// undefined;</span></div><div class="line"><span class="keyword">typeof</span> b; <span class="comment">// undefined;</span></div></pre></td></tr></table></figure>
<p>Null值表示一个空对象指针，所以 typeof null == undefined;</p>
<p>undefined 是派生于null值的，所以 null == undefined;</p>
<p>NaN参与任何计算都会返回NaN，所以NaN与任何值都不相等，包括其自身。所以要判断NaN，可以用isNaN函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<p>Number():</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num1 = <span class="built_in">Number</span>(<span class="string">"Hello world!"</span>); <span class="comment">//NaN</span></div><div class="line"><span class="keyword">var</span> num1 = <span class="built_in">Number</span>(<span class="literal">undefined</span>); <span class="comment">//NaN</span></div><div class="line"><span class="keyword">var</span> num1 = <span class="built_in">Number</span>(<span class="literal">null</span>); <span class="comment">//0</span></div><div class="line"><span class="keyword">var</span> num2 = <span class="built_in">Number</span>(<span class="string">""</span>); <span class="comment">//0</span></div><div class="line"><span class="keyword">var</span> num3 = <span class="built_in">Number</span>(<span class="string">"000011"</span>); <span class="comment">//11</span></div><div class="line"><span class="keyword">var</span> num4 = <span class="built_in">Number</span>(<span class="literal">true</span>); <span class="comment">//1</span></div><div class="line"></div><div class="line"><span class="comment">// 特别说明一下，一元操作符 + 号与Number效果相同； - 号是先执行Number后再变成负数。</span></div></pre></td></tr></table></figure>
<p>parseInt() &amp;&amp; parseFloat():</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseInt</span>(<span class="string">"1234blue"</span>); <span class="comment">// 1234</span></div><div class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseInt</span>(<span class="string">"sdas123"</span>); <span class="comment">// NaN</span></div><div class="line"><span class="keyword">var</span> num3 = <span class="built_in">parseInt</span>(<span class="string">"0xA"</span>); <span class="comment">// 10（十六进制数）</span></div><div class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseInt</span>(<span class="number">22.5</span>); <span class="comment">// 22</span></div><div class="line"><span class="keyword">var</span> num5 = <span class="built_in">parseInt</span>(<span class="number">070</span>); <span class="comment">// 56（八进制数）</span></div><div class="line"><span class="keyword">var</span> num5 = <span class="built_in">parseInt</span>(<span class="string">"070"</span>); <span class="comment">// 70（字符串会去掉前置的0）</span></div><div class="line"><span class="keyword">var</span> num6 = <span class="built_in">parseInt</span>(<span class="string">"70"</span>); <span class="comment">// 70（十进制数）</span></div><div class="line"><span class="keyword">var</span> num7 = <span class="built_in">parseInt</span>(<span class="string">"0xf"</span>); <span class="comment">// 15（十六进制数）</span></div><div class="line"></div><div class="line"><span class="comment">// parseInt 的第二个参数可以指定按什么进制去解析</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseFloat</span>(<span class="string">"1234blue"</span>); <span class="comment">//1234 （整数）</span></div><div class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseFloat</span>(<span class="string">"0xA"</span>); <span class="comment">//0</span></div><div class="line"><span class="keyword">var</span> num3 = <span class="built_in">parseFloat</span>(<span class="string">"22.5"</span>); <span class="comment">//22.5</span></div><div class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseFloat</span>(<span class="string">"22.34.5"</span>); <span class="comment">//22.34</span></div><div class="line"><span class="keyword">var</span> num5 = <span class="built_in">parseFloat</span>(<span class="string">"0908.5"</span>); <span class="comment">//908.5</span></div><div class="line"><span class="keyword">var</span> num6 = <span class="built_in">parseFloat</span>(<span class="string">"3.125e7"</span>); <span class="comment">//31250000</span></div></pre></td></tr></table></figure>
<h5 id="字符串："><a href="#字符串：" class="headerlink" title="字符串："></a>字符串：</h5><p>ECMAScript 中的字符串是<strong>不可变的</strong>，也就是说，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首<strong>先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量</strong>。</p>
<p>除了null和undefined，其他的数据类型都有toString方法。转换类型函数String()，就是调用参数的toString方法。如果传入null和undefined，会返回“null”和”undefined”。</p>
<h5 id="对象："><a href="#对象：" class="headerlink" title="对象："></a>对象：</h5><p>在 ECMAScript 中，（就像 Java 中的 java.lang.Object 对象一样） Object 类型是所有它的实例的基础。换句话说，Object 类型所具有的任何属性和方法也同样存在于更具体的对象中。</p>
<p>Object的每个实例都具有下列属性和方法：</p>
<ul>
<li>constructor ：保存着用于创建当前对象的构造函数。</li>
<li>hasOwnProperty(propertyName) ：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（ propertyName ）必须以字符串形式指定（例如： o.hasOwnProperty(“name”) ）。</li>
<li>isPrototypeOf(object) ：用于检查传入的对象是否是传入对象的原型。</li>
<li>propertyIsEnumerable(propertyName) ：用于检查给定的属性是否能够使用 for-in 语句（本章后面将会讨论）来枚举。与 hasOwnProperty() 方法一样，作为参数的属性名必须以字符串形式指定。</li>
<li>toLocaleString() ：返回对象的字符串表示，该字符串与执行环境的地区对应。</li>
<li>toString() ：返回对象的字符串表示。</li>
<li>valueOf() ：返回对象的字符串、数值或布尔值表示。通常与 toString() 方法的返回值<br>相同。</li>
</ul>
<h4 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h4><h5 id="一元操作符：-；-–"><a href="#一元操作符：-；-–" class="headerlink" title="一元操作符： ++ ； –"></a>一元操作符： ++ ； –</h5><p>递增和递减，可以写在元素的前面或者后面。</p>
<p>执行前置递增和递减操作时，变量的值都是在语句被<strong>求值以前改变</strong>的（反之则是在求值之后才改变）。（在计算机科学领域，这种情况通常被称作副效应。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> age = <span class="number">29</span>;</div><div class="line"><span class="keyword">var</span> anotherAge = --age + <span class="number">2</span>;</div><div class="line">alert(age); <span class="comment">// 输出 28</span></div><div class="line">alert(anotherAge); <span class="comment">// 输出 30</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> num1 = <span class="number">2</span>;</div><div class="line"><span class="keyword">var</span> num2 = <span class="number">20</span>;</div><div class="line"><span class="keyword">var</span> num3 = num1-- + num2; <span class="comment">//  等于 22</span></div><div class="line"><span class="keyword">var</span> num4 = num1 + num2; <span class="comment">// 等于 21</span></div></pre></td></tr></table></figure>
<ul>
<li>加号 + ：</li>
</ul>
<p>如果两个操作符都是数值，执行常规的加法计算，然后根据下列规则返回结果：<br>  如果有一个操作数是 NaN ，则结果是 NaN ；<br>  如果是 Infinity 加 Infinity ，则结果是 Infinity ；<br>  如果是 -Infinity 加 -Infinity ，则结果是 -Infinity ；<br>  如果是 Infinity 加 -Infinity ，则结果是 NaN ；<br>  如果是+0 加+0，则结果是+0；<br>  如果是0 加0，则结果是0；<br>  如果是+0 加0，则结果是+0。<br><strong>不过，如果有一个操作数是字符串，那么就要应用如下规则：</strong><br>  如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来；<br>  如果只有一个操作数是字符串，则将另一个操作数转换为字符串（调用toString），然后再将两个字符串拼接起来。</p>
<ul>
<li>减号 - ：</li>
</ul>
<p>  如果有一个操作数是字符串、布尔值、 null 或 undefined ，则先在后台调用 Number() 函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是 NaN ，则减法的结果就是 NaN ；<br>  如果有一个操作数是对象，则调用对象的 valueOf() 方法以取得表示该对象的数值。如果得到的值是 NaN ，则减法的结果就是 NaN 。如果对象没有 valueOf() 方法，则调用其 toString()方法并将得到的字符串转换为数值。</p>
<ul>
<li><p>比较符号 &gt; 、&lt;、 &gt;=、 &lt;=<br>比较符号都会返回一个布尔值，在不是数字的时候：</p>
<p>  如果两个操作数都是字符串，则比较两个字符串首字符对应的字符编码值。<br>  如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。<br>  如果一个操作数是对象，则调用这个对象的 valueOf() 方法，用得到的结果按照前面的规则执行比较。如果对象没有 valueOf() 方法，则调用 toString() 方法，并用得到的结果根据前面的规则执行比较。<br>  如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。</p>
</li>
</ul>
<h5 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h5><p>逻辑非 ！：</p>
<p>逻辑非操作符也可以用于将一个值转换为与其对应的布尔值。而同时使用两个逻辑非操作符，实际上就会模拟 Boolean() 转型函数的行为。</p>
<p>逻辑与 &amp;&amp; ：</p>
<p>在两个数值都是布尔的情况下，只要有一个是false，就都返回false。</p>
<p>但是逻辑与操作符可以应用于任何字符，常见的情况有：</p>
<p>  如果第一个操作数是对象，则返回第二个操作数；<br>  如果第二个操作数是对象，则只有在第一个操作数的求值结果为 true 的情况下才会返回该对象；<br>  如果两个操作数都是对象，则返回第二个操作数；<br>  如果有一个操作数是 null ，则返回 null ；<br>  如果有一个操作数是 NaN ，则返回 NaN ；<br>  如果有一个操作数是 undefined ，则返回 undefined 。</p>
<p>逻辑与操作属于<strong>短路操作</strong>，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。对于逻辑与操作而言，如果第一个操作数是 false ，则无论第二个操作数是什么都不重要，因为后面的代码不会再执行了。</p>
<p>逻辑或 || :</p>
<p>逻辑与操作也是一个短路操作。只要有一个true，就会返回true；</p>
<p>作用于其他数值时：</p>
<p>  如果第一个操作数是对象，则返回第一个操作数；<br>  如果第一个操作数的求值结果为 false ，则返回第二个操作数；<br>  如果两个操作数都是对象，则返回第一个操作数；<br>  如果两个操作数都是 null ，则返回 null ；<br>  如果两个操作数都是 NaN ，则返回 NaN ；<br>  如果两个操作数都是 undefined ，则返回 undefined 。</p>
<p>相等符号 = ：</p>
<p>== 和 ！= 都会先进行类型的强制转换，规则为：</p>
<p>  如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值—— false 转换为 0，而true 转换为 1；<br>  如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值；<br>  如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf() 方法，用得到的基本类型值按照前面的规则进行比较；<br>这两个操作符在进行比较时则要遵循下列规则。<br> null 和 undefined 是相等的。<br>  要比较相等性之前，不能将 null 和 undefined 转换成其他任何值。<br>  如果有一个操作数是 NaN ，则相等操作符返回 false ，而不相等操作符返回 true 。重要提示：即使两个操作数都是 NaN ，相等操作符也返回 false ；因为按照规则， NaN 不等于 NaN 。<br>  如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true ；否则，返回 false 。</p>
<h4 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h4><ul>
<li><p>do while 是后测试语句，会先执行一次再去判读，而while是前测试。</p>
</li>
<li><p>label语句可以配合for循环精准控制代码流程，一般用于嵌套循环：</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</div><div class="line">outermost:</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</div><div class="line">		<span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123;</div><div class="line">			<span class="keyword">break</span> outermost; <span class="comment">// 退出外层循环</span></div><div class="line">		&#125;</div><div class="line">	num++;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">alert(num); <span class="comment">//55</span></div></pre></td></tr></table></figure>
<ul>
<li>switch 语句判断时使用的是全等</li>
</ul>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-07-06</span><i class="fa fa-tag"></i><a href="/Blog/tags/javascript/" title="javascript" class="tag">javascript </a></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,http://wqy.fun/Blog/2019/07/06/重读高程-基本语法/,清野流云,重读高程-基本语法,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/Blog/2019/07/06/重读高程-变量、作用域与内存/" title="重读高程-变量、作用域与内存" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/Blog/2019/06/19/什么是原型链/" title="This、原型链以及继承" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/Blog/js/jquery.js"></script><script src="/Blog/js/jquery-migrate-1.2.1.min.js"></script><script src="/Blog/js/jquery.appear.js"></script></body></html>