<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="清野君"><title>Vue源码系列1-Vue3.0的优化点 · 清野流云</title><meta name="description" content="Vue3.0的优化vue1.0 到 vue2.0最大的升级就是引入了虚拟 DOM 的概念，它为后续做服务端渲染以及跨端框架 Weex 提供了基础。
1、源码优化源码的优化主要体现在使用 monorepo 和 TypeScript 管理和开发源码，这样做的目标是提升自身代码可维护性。
monorepo"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/Blog/css/style.css"><link rel="stylesheet" href="/Blog/css/blog_basic.css"><link rel="stylesheet" href="/Blog/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/Blog/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">清野流云</a></h3></div></div><ul class="social-links"></ul><div class="footer"><!-- a(target="_blank", href="/")--><!--   span Theme by --><!-- a(href="https://www.caicai.me")  CaiCai --><!-- span &--><!-- a(href="https://github.com/Ben02/hexo-theme-Anatole")  Ben--><!-- .by_farbox--><!--   a(href="https://hexo.io/zh-cn/", target="_blank") Proudly published with Hexo&#65281;--></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="http://wqy.fun/Blog">首页</a></li><!-- li--><!--   if is_current('about')--><!--     a.current(href="/about")= __('About')			--><!--   else--><!--     a(href="/about")= __('About')--><li><a href="http://wqy.fun/Blog/archives">归档</a></li><!-- li--><!--   if is_current('links')--><!--     a.current(href="/links")= __('Links')					--><!--   else--><!--     a(href="/links")= __('Links')		--></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Vue源码系列1-Vue3.0的优化点</a></h3></div><div class="post-content"><h2 id="Vue3-0的优化"><a href="#Vue3-0的优化" class="headerlink" title="Vue3.0的优化"></a>Vue3.0的优化</h2><p>vue1.0 到 vue2.0最大的升级就是引入了虚拟 DOM 的概念，它为后续做服务端渲染以及跨端框架 Weex 提供了基础。</p>
<h4 id="1、源码优化"><a href="#1、源码优化" class="headerlink" title="1、源码优化"></a>1、源码优化</h4><p>源码的优化主要体现在使用 monorepo 和 TypeScript 管理和开发源码，这样做的目标是提升自身代码可维护性。</p>
<h5 id="monorepo"><a href="#monorepo" class="headerlink" title="monorepo"></a>monorepo</h5><p>本质上从以前把所有代码根据模块放置在src目录下改成了分成不同的项目放在packages下，每个 package 有各自的 API、类型定义和测试。这样使得模块拆分更细化，职责划分更明确，模块之间的依赖关系也更加明确，开发人员也更容易阅读、理解和更改所有模块源码，提高代码的可维护性。</p>
<p>另外一些 package（比如 reactivity 响应式库）是可以独立于 Vue.js 使用的，这样用户如果只想使用 Vue.js 3.0 的响应式能力，可以单独依赖这个响应式库而不用去依赖整个 Vue.js，减小了引用包的体积大小，而 Vue.js 2 .x 是做不到这一点的。</p>
<p><img src="https://s0.lgstatic.com/i/image/M00/2C/DC/Ciqc1F8Cn6mAHaUrAACzRBFsL1g844.png" alt=""></p>
<p><img src="https://s0.lgstatic.com/i/image/M00/2C/DC/Ciqc1F8Cn7KAELkqAAJkxFes1zw593.png" alt=""></p>
<h5 id="用TypeScript开发"><a href="#用TypeScript开发" class="headerlink" title="用TypeScript开发"></a>用TypeScript开发</h5><p>Vue.js 3.0 抛弃 Flow 后，使用 TypeScript 重构了整个项目。 TypeScript提供了更好的类型检查，能支持复杂的类型推导；由于源码就使用 TypeScript 编写，也省去了单独维护 d.ts 文件的麻烦；就整个 TypeScript 的生态来看，TypeScript 团队也是越做越好，TypeScript 本身保持着一定频率的迭代和更新，支持的 feature 也越来越多。</p>
<h4 id="2、性能优化"><a href="#2、性能优化" class="headerlink" title="2、性能优化"></a>2、性能优化</h4><h5 id="源码体积优化"><a href="#源码体积优化" class="headerlink" title="源码体积优化"></a>源码体积优化</h5><ul>
<li><p>移除了一些冷门feature（filter、inline-template等）</p>
</li>
<li><p>引入tree-shaking，减少打包体积。</p>
<p>tree-shaking 依赖 ES2015 模块语法的静态结构（即 import 和 export），通过编译阶段的静态分析，找到没有引入的模块并打上标记。</p>
<p>webpack打包好的文件会标记上没有被引用的代码块，然后压缩阶段会利用例如 uglify-js、terser 等压缩工具真正地删除这些没有用到的代码。</p>
</li>
</ul>
<h5 id="数据劫持优化"><a href="#数据劫持优化" class="headerlink" title="数据劫持优化"></a>数据劫持优化</h5><p><img src="https://s0.lgstatic.com/i/image/M00/2C/FF/CgqCHl8CudyAJc3tAAGkPxYyp9k501.png" alt=""></p>
<p>Vue.js 1.x 和 Vue.js 2.x 内部都是通过 Object.defineProperty 这个 API 去劫持数据的 getter 和 setter，具体是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.defineProperty(data, <span class="string">'a'</span>,&#123;</div><div class="line">  get()&#123;</div><div class="line">    <span class="comment">// track</span></div><div class="line">  &#125;,</div><div class="line">  set()&#123;</div><div class="line">    <span class="comment">// trigger</span></div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>此API的缺陷是<strong>并不能检测对象属性的添加和删除，还有无法检测到数组的变化</strong>。尽管 Vue.js 为了解决这个问题提供了 $set 和 $delete 实例方法，但是对于用户来说，还是增加了一定的心智负担。<strong>其次面对嵌套层次比较深的时候，需要将每一层对象都遍历成响应式对象，对性能负担很大。</strong></p>
<p>Vue3.0采用了ES6新的API Proxy：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">observed = <span class="keyword">new</span> <span class="built_in">Proxy</span>(data, &#123;</div><div class="line">  get() &#123;</div><div class="line">    <span class="comment">// track</span></div><div class="line">  &#125;,</div><div class="line">  set() &#123;</div><div class="line">    <span class="comment">// trigger</span></div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>Proxy劫持的是整个对象，所以能够监听到对象属性的删除和增加。都是注意的是Proxy并不能监听到内部深层次对象的变化，所以Vue3.0选择了在getter中去递归响应式，这样的好处是只对真正访问到的对象做了响应式。</p>
<h5 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h5><p><img src="https://s0.lgstatic.com/i/image/M00/2C/FF/CgqCHl8Cuf2AZw70AAEFU2EMA50521.png" alt=""></p>
<p>上图是整个vue的渲染流程，一般<strong>响应式的过程是发生在init阶段</strong>，<strong>另外 template compile to render function 的流程是可以借助 vue-loader 在 webpack 编译阶段离线完成</strong>，并非一定要在运行时完成。</p>
<p>所以整个vue运行时，除了响应式部分的优化，还可以在耗时最多的patch部分做优化。</p>
<p>通过数据劫持和依赖收集，Vue.js 2.x 的数据更新并触发重新渲染的粒度是组件级的。</p>
<p>虽然 Vue 能保证触发更新的组件最小化，但在单个组件内部依然需要遍历该组件的整个 vnode 树，举个例子，比如我们要更新这个组件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"text"</span>&gt;</span>static text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"text"</span>&gt;</span>static text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"text"</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"text"</span>&gt;</span>static text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"text"</span>&gt;</span>static text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div></pre></td></tr></table></figure>
<p><img src="https://s0.lgstatic.com/i/image/M00/2C/F4/Ciqc1F8CuiGALtCjAADLSWA_APA121.png" alt=""></p>
<p>可以看到，因为这段代码中只有一个动态节点，所以这里有很多 diff 和遍历其实都是不需要的，这就会导致 vnode 的性能跟模版大小正相关，跟动态节点的数量无关，当一些组件的整个模版内只有少量动态节点时，这些遍历都是性能的浪费。</p>
<p>Vue.js 3.0 做到了，<strong>它通过编译阶段对静态模板的分析，编译生成了 Block tree。Block tree 是一个将模版基于动态节点指令切割的嵌套区块，每个区块内部的节点结构是固定的，而且每个区块只需要以一个 Array 来追踪自身包含的动态节点。</strong>借助 Block tree，Vue.js 将 vnode <strong>更新性能由与模版整体大小相关提升为与动态内容的数量相关</strong>，这是一个非常大的性能突破，我会在后续的章节详细分析它是如何实现的。</p>
<p>除此之外，Vue.js 3.0 在编译阶段还包含了对 <strong>Slot 的编译优化、事件侦听函数的缓存优化，并且在运行时重写了 diff 算法</strong>，这些性能优化的内容我在后续特定的章节与你分享。</p>
<h5 id="语法优化：Composition-API"><a href="#语法优化：Composition-API" class="headerlink" title="语法优化：Composition API"></a>语法优化：Composition API</h5><p><strong>逻辑组织</strong></p>
<p><img src="https://s0.lgstatic.com/i/image/M00/2C/E9/CgqCHl8CoI-ACOXEAAM5NZiddQs980.png" alt=""></p>
<p>以前在组件中描述组件固定部分需要写在固定的API中，如果是逻辑比较复杂的组件，那么在同一条逻辑线中，就需要进行代码的跳转。采用Compostion API 可以将<strong>同一条线的逻辑写在同一块，使代码更加清晰。</strong></p>
<p><strong>逻辑复用</strong></p>
<p>在2.0中一般使用mixins来实现复用，使用单个 mixin 似乎问题不大，但是当我们一个组件混入<strong>大量不同的 mixins 的时候</strong>，会存在两个非常明显的问题：<strong>命名冲突和数据来源不清晰</strong>。</p>
<p>采用Composition API的方式写Hook函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; ref, onMounted, onUnmounted &#125; <span class="keyword">from</span> <span class="string">'vue'</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">useMousePosition</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> x = ref(<span class="number">0</span>)</div><div class="line">  <span class="keyword">const</span> y = ref(<span class="number">0</span>)</div><div class="line">  <span class="keyword">const</span> update = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</div><div class="line">    x.value = e.pageX</div><div class="line">    y.value = e.pageY</div><div class="line">  &#125;</div><div class="line">  onMounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'mousemove'</span>, update)</div><div class="line">  &#125;)</div><div class="line">  onUnmounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">'mousemove'</span>, update)</div><div class="line">  &#125;)</div><div class="line">  <span class="keyword">return</span> &#123; x, y &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在组件中引用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;template&gt;</div><div class="line">  &lt;div&gt;</div><div class="line">    Mouse position: x &#123;&#123; x &#125;&#125; / y &#123;&#123; y &#125;&#125;</div><div class="line">  &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">&lt;/</span>template&gt;</div><div class="line">&lt;script&gt;</div><div class="line">  <span class="keyword">import</span> useMousePosition <span class="keyword">from</span> <span class="string">'./mouse'</span></div><div class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">    setup() &#123;</div><div class="line">      <span class="keyword">const</span> &#123; x, y &#125; = useMousePosition()</div><div class="line">      <span class="keyword">return</span> &#123; x, y &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure>
<p>可以看到，整个数据来源清晰了，即使去编写更多的 hook 函数，也不会出现命名冲突的问题。</p>
<p>Composition API 除了在逻辑复用方面有优势，也会有更好的类型支持，因为它们都是一些函数，在调用函数时，<strong>自然所有的类型就被推导出来了</strong>，不像 Options API 所有的东西使用 this。另外，<strong>Composition API 对 tree-shaking 友好，代码也更容易压缩。</strong></p>
<p>虽然 Composition API 有诸多优势，它也不是一点缺点都没有，关于它的具体用法和设计原理，我们会在后续的章节详细说明。这里还需要说明的是，Composition API 属于 API 的增强，它并不是 Vue.js 3.0 组件开发的范式，如果你的组件足够简单，你还是可以使用 Options API。</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-07-20</span><i class="fa fa-tag"></i><a href="/Blog/tags/vue/" title="vue" class="tag">vue </a></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,http://wqy.fun/Blog/2020/07/20/Vue源码系列1-Vue3.0的优化点/,清野流云,Vue源码系列1-Vue3.0的优化点,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/Blog/2020/07/22/Vue源码系列3-完整的 DOM diff 流程是怎样的 (2)/" title="Vue源码系列1-Vnode到真实node的渲染（2）" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/Blog/2019/07/18/重读高程-面向对象的程序设计/" title="重读高程-面向对象的程序设计" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/Blog/js/jquery.js"></script><script src="/Blog/js/jquery-migrate-1.2.1.min.js"></script><script src="/Blog/js/jquery.appear.js"></script></body></html>